# 📘 포함 관계(has-a)

## 🎯 오늘 학습 목표
- 클래스 간의 포함 관계(has-a)를 명확히 이해하고, 코드로 구현한다
- 생성자에서 포함 객체를 전달하는 구조를 익힌다
- 포함된 객체의 메서드와 필드에 접근하는 방식(`.` 연산자)을 익숙하게 만든다
- 현실 세계를 반영한 객체 조합 방식의 설계 철학을 경험한다

---

## 🧠 오늘 배운 개념

### 🔹 포함 관계 (has-a)
- 한 클래스가 **다른 클래스의 인스턴스를 멤버로 포함**하는 관계
- 예: `사람 has-a 주소`, `컴퓨터 has-a CPU`
- 설계가 **분리되고**, 구성 요소가 재사용되며, 유지보수성 향상

### 🔹 생성자를 통한 포함 객체 연결
- 포함할 객체를 생성 후, 다른 객체의 생성자에 넘겨서 조합 가능
- 구조적으로 “이 객체가 저 객체를 가진다”는 명확한 표현 가능

### 🔹 접근 방식
- 포함된 객체는 `.필드`, `.메서드()` 형태로 접근 가능
- `p.address.city` 처럼 다단계 접근 가능

---

### 🔹 실습 중 사용한 명령어 요약
```java
Address a = new Address("서울", "강남대로");   //포함될 객체 생성
Person p = new Person("희성", a);           //포함 객체를 생성자에 전달
p.showInfo();                              // 포함 객체의 메서드 사용
p.address.city                             // 내부 필드 직접 접근 예시
```

---

## 🧪 실습 과정 요약
1. `Address` 클래스와 `Person` 클래스를 분리하여 정의
2. `Person` 클래스가 `Address`를 멤버로 가지는 구조로 설계
3. 객체 생성 후 생성자에서 포함 객체를 전달해 연결
4. 포함 객체의 필드/메서드를 점(.) 연산자로 접근하여 정보 출력

---

## ⚠️ 실수 & 깨달은 점
- 포함 객체를 new 하지 않거나 연결하지 않으면 NullPointerException 발생할 수 있음
- 클래스를 작게 나누고, 필요 시 서로 조합하는 방식이 더 설계적으로 안전함
- 모든 역할을 한 클래스에 몰아넣는 구조는 유지보수가 어렵고 비효율적임

---

## 💭 느낀 점
- "객체는 객체를 가질 수 있다"는 설계 개념이 처음엔 어색했지만, 사람과 주소 같은 예시로 이해되니 직관적이었다
- 포함 관계를 통해 현실 세계 구조를 코드로 반영할 수 있다는 게 객체지향의 강점이라는 걸 느꼈다
- 앞으로도 큰 클래스를 작게 나누고, 조합해서 설계하는 방식에 익숙해지고 싶다
