# 📘 상속 기본 구조와 super() 호출

## 🎯 오늘 학습 목표
- 클래스 간 상속 구조를 이해하고 `extends` 키워드를 사용할 수 있다
- 자식 클래스가 부모 클래스의 필드와 메서드를 상속받는 동작을 확인한다
- 생성자에서 `super()`를 통해 부모 생성자를 호출하는 구조를 익힌다

---

## 🧠 오늘 배운 개념

### 🔹 상속 (`extends`)
- 자식 클래스가 부모 클래스의 필드 및 메서드를 자동으로 물려받음
- 자바에서 상속은 `extends` 키워드로 표현함
- 상속은 중복 제거, 유지보수성 향상, 확장성 확보에 도움됨

### 🔹 super() 생성자 호출
- 자식 클래스 생성자에서 부모 생성자를 호출할 때 `super()` 사용
- `super()`는 생성자의 첫 줄에서만 사용 가능
- 부모 클래스가 매개변수를 요구할 경우 반드시 `super(값)` 형태로 호출해야 함

---

### 🔹 실습 중 사용한 명령어 요약

```java
class Student extends Person { ... } // 클래스 상속
super(name, age); // 부모 생성자 호출
s.introduce();    // 부모 메서드 호출
s.study();        // 자식 고유 메서드 호출
```

---

## 🧪 실습 과정 요약
1. 부모 클래스 `Person`에 name, age 필드와 introduce() 메서드를 정의함
2. 자식 클래스 `Student`에서 `extends Person`으로 상속 선언
3. 자식 생성자에서 `super(name, age)`를 사용해 부모 생성자를 호출함
4. Student 객체 생성 후, 부모의 introduce() 메서드와 자식의 study() 메서드를 호출함
5. 출력 결과를 통해 자식 클래스가 부모의 필드/메서드를 그대로 사용할 수 있음을 확인함

---

## ⚠️ 실수 & 깨달은 점
- 부모 클래스의 생성자가 매개변수를 요구할 경우 자식 생성자에서 반드시 `super(값)`으로 호출해야 한다는 것을 실습을 통해 체득함
- super()는 반드시 **생성자 첫 줄**에 위치해야 하며, 위치가 잘못되면 컴파일 에러가 발생함
- 부모의 private 필드는 자식이 직접 접근할 수 없다는 점을 다시 한 번 확인함 (필요 시 getter/setter로 접근)

---

## 💭 느낀 점
- 클래스 상속은 단순히 기능을 복사하는 것이 아니라, 코드를 구조적으로 재사용하는 방법이라는 점을 명확히 이해함
- 생성자 호출 순서와 super()의 위치가 얼마나 중요한지를 몸소 체험함
- 앞으로 객체 간 관계를 설계할 때 상속을 통해 **공통 기능을 위로 끌어올리고**, 자식 클래스는 차별화된 기능만 담당하도록 구성할 수 있다는 자신감이 생김
